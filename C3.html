<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grid-Based Adventure 3D Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; overflow:hidden; touch-action:none; background:#000; }
#score { position: fixed; top:10px; left:10px; color:white; font-family:sans-serif; font-size:18px; z-index:10; }
#joystick { position: fixed; bottom:30px; left:30px; width:120px; height:120px; background: rgba(0,0,0,0.35); border-radius:50%; z-index:10; }
#stick { position:absolute; left:35px; top:35px; width:50px; height:50px; background:rgba(255,255,255,0.85); border-radius:50%; }
#jumpBtn { position: fixed; bottom:40px; right:30px; width:90px; height:90px; border-radius:50%; background:rgba(255,255,255,0.7); font-size:20px; border:none; z-index:10; }
</style>
</head>
<body>
<div id="score">Collectibles: 0</div>
<div id="joystick"><div id="stick"></div></div>
<button id="jumpBtn">JUMP</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

/* ------------------ BASIC SETUP ------------------ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff,0.4));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(10,20,10); scene.add(sun);

/* ------------------ PLAYER ------------------ */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(0.8,0.8,0.8),
  new THREE.MeshStandardMaterial({color:0xff4444})
);
scene.add(player);
const SPAWN_X=0, SPAWN_Y=5;
player.position.set(SPAWN_X,SPAWN_Y,0);

let velocityY=0, gravity=-0.025, onGround=false;

/* ------------------ INPUT ------------------ */
const keys={w:false,a:false,s:false,d:false};
document.addEventListener("keydown",e=>{
  if(e.key==="w"||e.key==="ArrowUp") keys.w=true;
  if(e.key==="s"||e.key==="ArrowDown") keys.s=true;
  if(e.key==="a"||e.key==="ArrowLeft") keys.a=true;
  if(e.key==="d"||e.key==="ArrowRight") keys.d=true;
  if(e.key===" " && onGround){ velocityY=0.45; onGround=false; }
});
document.addEventListener("keyup",e=>{
  if(e.key==="w"||e.key==="ArrowUp") keys.w=false;
  if(e.key==="s"||e.key==="ArrowDown") keys.s=false;
  if(e.key==="a"||e.key==="ArrowLeft") keys.a=false;
  if(e.key==="d"||e.key==="ArrowRight") keys.d=false;
});

/* ------------------ ANALOG JOYSTICK ------------------ */
let joyX=0, joyZ=0, dragging=false;
const joystick=document.getElementById("joystick");
const stick=document.getElementById("stick");

joystick.addEventListener("touchstart",()=>dragging=true);
joystick.addEventListener("touchmove",e=>{
  if(!dragging) return;
  const r=joystick.getBoundingClientRect();
  let x=e.touches[0].clientX-r.left-60;
  let y=e.touches[0].clientY-r.top-60;
  x=Math.max(-50,Math.min(50,x));
  y=Math.max(-50,Math.min(50,y));
  joyX=x/50; joyZ=-y/50;
  stick.style.left=(35+x*0.6)+"px";
  stick.style.top=(35+y*0.6)+"px";
});
joystick.addEventListener("touchend",()=>{
  dragging=false; joyX=0; joyZ=0; stick.style.left="35px"; stick.style.top="35px";
});

/* ------------------ JUMP BUTTON ------------------ */
document.getElementById("jumpBtn").addEventListener("touchstart",()=>{
  if(onGround){ velocityY=0.45; onGround=false; }
});

/* ------------------ CAMERA ORBIT ------------------ */
let camAngle=0, camTilt=0.45, camDist=12;
let camDrag=false, lx=0, ly=0;

addEventListener("mousedown",e=>{camDrag=true; lx=e.clientX; ly=e.clientY;});
addEventListener("mouseup",()=>camDrag=false);
addEventListener("mousemove",e=>{
  if(!camDrag) return;
  camAngle-=(e.clientX-lx)*0.005; camTilt-=(e.clientY-ly)*0.005;
  camTilt=Math.max(0.15,Math.min(1.2,camTilt)); lx=e.clientX; ly=e.clientY;
});
addEventListener("touchstart",e=>{
  if(e.target.id==="joystick") return;
  camDrag=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY;
});
addEventListener("touchmove",e=>{
  if(!camDrag || e.target.id==="joystick") return;
  camAngle-=(e.touches[0].clientX-lx)*0.005; camTilt-=(e.touches[0].clientY-ly)*0.005;
  camTilt=Math.max(0.15,Math.min(1.2,camTilt)); lx=e.touches[0].clientX; ly=e.touches[0].clientY;
});
addEventListener("touchend",()=>camDrag=false);

/* ------------------ BIOMES & SEED ------------------ */
function seedRandom(seed){
  let x=Math.sin(seed)*10000;
  return function(){ x=Math.sin(x)*10000; return x-Math.floor(x); }
}

const biomes=[
  {name:"grass", color:0x228B22, gemChance:0.6},
  {name:"desert", color:0xEDC9AF, gemChance:0.4},
  {name:"snow", color:0xFFFFFF, gemChance:0.3}
];

/* ------------------ GRID & CHUNK SETTINGS ------------------ */
const GRID_SIZE=1;
const CHUNK_SIZE=10;
const VIEW=2;
const chunks={}, platforms=[], collectibles=[];
let score=0;
const scoreDiv=document.getElementById("score");
const globalSeed=12345;

/* ------------------ CREATE GRID-BASED CHUNK ------------------ */
function createChunk(chunkX, chunkZ){
  const key = chunkX + "," + chunkZ;
  if(chunks[key]) return;
  const rng=seedRandom(globalSeed + chunkX*1000 + chunkZ);
  const g=new THREE.Group();
  const biome=biomes[Math.floor(rng()*biomes.length)];

  for(let x=0;x<CHUNK_SIZE;x++){
    for(let z=0;z<CHUNK_SIZE;z++){
      const worldX = chunkX*CHUNK_SIZE*GRID_SIZE + x*GRID_SIZE;
      const worldZ = chunkZ*CHUNK_SIZE*GRID_SIZE + z*GRID_SIZE;

      // Y height biased toward 0
      const r = rng();
      let y=0;
      if(r<0.1) y=1;
      else if(r<0.15) y=-1;

      const pos=new THREE.Vector3(worldX, y, worldZ);

      // Prevent overlap (grid-aligned, so equality check works)
      if(platforms.some(p=>p.position.equals(pos))) continue;

      const platform=new THREE.Mesh(
        new THREE.BoxGeometry(GRID_SIZE,0.5,GRID_SIZE),
        new THREE.MeshStandardMaterial({color:biome.color})
      );
      platform.position.copy(pos);
      g.add(platform); platforms.push(platform);

      // Collectible
      if(rng()<biome.gemChance){
        const c=new THREE.Mesh(
          new THREE.BoxGeometry(0.4,0.4,0.4),
          new THREE.MeshStandardMaterial({color:0xffff00})
        );
        c.position.set(pos.x,pos.y+0.75,pos.z);
        g.add(c); collectibles.push(c);
      }
    }
  }

  scene.add(g); chunks[key]=g;
}

/* ------------------ REMOVE CHUNK ------------------ */
function removeChunk(chunkX, chunkZ){
  const key = chunkX + "," + chunkZ;
  if(!chunks[key]) return;
  chunks[key].children.forEach(o=>scene.remove(o));
  scene.remove(chunks[key]); delete chunks[key];
}

/* ------------------ COLLISION & GROUND ------------------ */
function platformCollision(){
  onGround=false;
  const playerHalf=0.4;
  platforms.forEach(p=>{
    const px=p.position.x, pz=p.position.z, py=p.position.y;
    const halfWidth=0.5, halfDepth=0.5;
    if(
      player.position.x + playerHalf > px - halfWidth &&
      player.position.x - playerHalf < px + halfWidth &&
      player.position.z + playerHalf > pz - halfDepth &&
      player.position.z - playerHalf < pz + halfDepth &&
      velocityY <= 0 &&
      player.position.y > py &&
      player.position.y - py <= 0.75
    ){
      player.position.y = py + 0.75;
      velocityY = 0;
      onGround = true;
    }
  });
}

/* ------------------ COLLECTIBLES ------------------ */
function collectCheck(){
  for(let i=collectibles.length-1;i>=0;i--){
    const c=collectibles[i];
    if(c && player.position.distanceTo(c.position)<0.6){
      if(c.parent) c.parent.remove(c);
      collectibles.splice(i,1);
      score++;
      scoreDiv.textContent = "Collectibles: "+score;
    }
  }
}

/* ------------------ TERRAIN STREAMING ------------------ */
function generateChunksAroundPlayer(){
  const ciX=Math.floor(player.position.x/CHUNK_SIZE);
  const ciZ=Math.floor(player.position.z/CHUNK_SIZE);

  for(let dx=-VIEW; dx<=VIEW; dx++){
    for(let dz=-VIEW; dz<=VIEW; dz++){
      createChunk(ciX+dx, ciZ+dz);
    }
  }

  Object.keys(chunks).forEach(key=>{
    const [x,z]=key.split(",").map(Number);
    if(Math.abs(x-ciX)>VIEW || Math.abs(z-ciZ)>VIEW){
      removeChunk(x,z);
    }
  });
}

/* ------------------ GAME LOOP ------------------ */
function animate(){
  requestAnimationFrame(animate);

  const moveSpeed=0.15;
  const forward=new THREE.Vector3();
  camera.getWorldDirection(forward); forward.y=0; forward.normalize();
  const right=new THREE.Vector3();
  right.crossVectors(forward, new THREE.Vector3(0,1,0));

  const mx=joyX + (keys.d?1:0) - (keys.a?1:0);
  const mz=joyZ + (keys.w?1:0) - (keys.s?1:0);

  player.position.addScaledVector(forward, mz*moveSpeed);
  player.position.addScaledVector(right, mx*moveSpeed);

  velocityY+=gravity; player.position.y+=velocityY;
  platformCollision();
  collectCheck();

  if(player.position.y<-20){
    player.position.set(SPAWN_X,SPAWN_Y,0); velocityY=0;
  }

  generateChunksAroundPlayer();

  camera.position.set(
    player.position.x + Math.sin(camAngle)*camDist,
    player.position.y + camTilt*camDist,
    player.position.z + Math.cos(camAngle)*camDist
  );
  camera.lookAt(player.position);

  renderer.render(scene,camera);
}
animate();

/* ------------------ RESIZE ------------------ */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
