<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JSON Driven 3D Platformer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>

<script type="module">
import * as THREE from "three";

/* ================= COLORS ================= */
const COLORS = {
  green: 0x4caf50,   // grass / floor
  purple: 0xff00ff,  // accent
  cyan: 0x00ffff,    // accent
  yellow: 0xffff00,  // accent
  orange: 0xff8800,  // player
  red: 0xff4444,     // danger
  blue: 0x2196f3,    // sky
  white: 0xffffff,   // light
  gray: 0x888888     // walls
};

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(COLORS.blue);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

camera.position.set(8, 8, 8);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(COLORS.white, 0.6));

const sun = new THREE.DirectionalLight(COLORS.white, 0.6);
sun.position.set(5, 10, 5);
scene.add(sun);

/* ================= DATA ================= */
let platforms = [];
let platformMeshes = [];
let playerData;
let player;

/* ================= PLAYER PHYSICS ================= */
const velocity = { x: 0, y: 0, z: 0 };
const gravity = -0.015;
let onGround = false;

/* ================= INPUT ================= */
const input = { left:false, right:false, forward:false, back:false, jump:false };

window.addEventListener("keydown", e => {
  if (e.code === "KeyA") input.left = true;
  if (e.code === "KeyD") input.right = true;
  if (e.code === "KeyW") input.forward = true;
  if (e.code === "KeyS") input.back = true;
  if (e.code === "Space") input.jump = true;
});

window.addEventListener("keyup", e => {
  if (e.code === "KeyA") input.left = false;
  if (e.code === "KeyD") input.right = false;
  if (e.code === "KeyW") input.forward = false;
  if (e.code === "KeyS") input.back = false;
  if (e.code === "Space") input.jump = false;
});

/* ================= JSON LOADER ================= */
async function loadJSON(path) {
  const r = await fetch(path);
  return await r.json();
}

/* ================= PLATFORM ================= */
function createPlatform(p) {
  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(
      p.size.width,
      p.size.height,
      p.size.depth
    ),
    new THREE.MeshStandardMaterial({
      color: COLORS[p.color] ?? COLORS.gray
    })
  );

  mesh.position.set(
    p.position.x,
    p.position.y + p.size.height / 2,
    p.position.z
  );

  mesh.userData = p;

  scene.add(mesh);
  platformMeshes.push(mesh);
}

/* ================= PROCEDURAL ================= */
function generatePlatforms() {
  platformMeshes.forEach(mesh => {
    const p = mesh.userData;
    if (!p.generatiable) return;
    if (p.generatedCount >= p.generatiableLimit) return;

    const dirs = [
      { x: 1, z: 0 },
      { x: -1, z: 0 },
      { x: 0, z: 1 },
      { x: 0, z: -1 }
    ];

    dirs.forEach(d => {
      const np = structuredClone(p);
      np.position.x += d.x * p.size.width;
      np.position.z += d.z * p.size.depth;
      np.generatiable = false;
      createPlatform(np);
    });

    p.generatedCount++;
  });
}

/* ================= PLAYER ================= */
function createPlayer() {
  player = new THREE.Mesh(
    new THREE.BoxGeometry(
      playerData.size.width,
      playerData.size.height,
      playerData.size.depth
    ),
    new THREE.MeshStandardMaterial({
      color: COLORS[playerData.color]
    })
  );

  player.position.set(
    playerData.position.x,
    playerData.position.y,
    playerData.position.z
  );

  scene.add(player);
}

/* ================= COLLISION ================= */
function collide(boxA, boxB) {
  return (
    Math.abs(boxA.x - boxB.x) < (boxA.w + boxB.w) / 2 &&
    Math.abs(boxA.y - boxB.y) < (boxA.h + boxB.h) / 2 &&
    Math.abs(boxA.z - boxB.z) < (boxA.d + boxB.d) / 2
  );
}

/* ================= GAME LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  velocity.y += gravity;

  if (input.left) velocity.x = -playerData.movement.speed;
  if (input.right) velocity.x = playerData.movement.speed;
  if (input.forward) velocity.z = -playerData.movement.speed;
  if (input.back) velocity.z = playerData.movement.speed;

  if (input.jump && onGround) {
    velocity.y = playerData.movement.jumpForce;
    onGround = false;
  }

  player.position.x += velocity.x;
  player.position.y += velocity.y;
  player.position.z += velocity.z;

  onGround = false;

  platformMeshes.forEach(m => {
    const p = m.userData;

    const a = {
      x: player.position.x,
      y: player.position.y,
      z: player.position.z,
      w: playerData.size.width,
      h: playerData.size.height,
      d: playerData.size.depth
    };

    const b = {
      x: m.position.x,
      y: m.position.y,
      z: m.position.z,
      w: p.size.width,
      h: p.size.height,
      d: p.size.depth
    };

    if (collide(a, b)) {
      if (p.floor && velocity.y <= 0) {
        player.position.y = b.y + b.h / 2 + a.h / 2;
        velocity.y = 0;
        onGround = true;
      }
      if (p.wall) {
        velocity.x = 0;
        velocity.z = 0;
      }
    }
  });

  velocity.x *= 0.8;
  velocity.z *= 0.8;

  renderer.render(scene, camera);
}

/* ================= INIT ================= */
async function init() {
  const pData = await loadJSON("./platforms.json");
  const plData = await loadJSON("./player.json");

  platforms = pData.platforms;
  playerData = plData.player;

  platforms.forEach(createPlatform);
  generatePlatforms();
  createPlayer();
  animate();
}

init();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
